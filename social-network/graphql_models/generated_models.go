// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql_models

import (
	"fmt"
	"io"
	"strconv"
)

type Node interface {
	IsNode()
}

type BooleanFilter struct {
	EqualTo    *bool `json:"equalTo"`
	NotEqualTo *bool `json:"notEqualTo"`
}

type Comment struct {
	ID           string         `json:"id"`
	Content      string         `json:"content"`
	Post         *Post          `json:"post"`
	User         *User          `json:"user"`
	CommentLikes []*CommentLike `json:"commentLikes"`
}

func (Comment) IsNode() {}

type CommentConnection struct {
	Edges    []*CommentEdge `json:"edges"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

type CommentCreateInput struct {
	Content string `json:"content"`
	PostID  string `json:"postId"`
	UserID  string `json:"userId"`
}

type CommentDeletePayload struct {
	ID string `json:"id"`
}

type CommentEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Comment `json:"node"`
}

type CommentFilter struct {
	Search *string       `json:"search"`
	Where  *CommentWhere `json:"where"`
}

type CommentLike struct {
	ID        string   `json:"id"`
	Comment   *Comment `json:"comment"`
	User      *User    `json:"user"`
	LikeType  string   `json:"likeType"`
	CreatedAt *int     `json:"createdAt"`
}

func (CommentLike) IsNode() {}

type CommentLikeConnection struct {
	Edges    []*CommentLikeEdge `json:"edges"`
	PageInfo *PageInfo          `json:"pageInfo"`
}

type CommentLikeCreateInput struct {
	CommentID string `json:"commentId"`
	UserID    string `json:"userId"`
	LikeType  string `json:"likeType"`
	CreatedAt *int   `json:"createdAt"`
}

type CommentLikeDeletePayload struct {
	ID string `json:"id"`
}

type CommentLikeEdge struct {
	Cursor string       `json:"cursor"`
	Node   *CommentLike `json:"node"`
}

type CommentLikeFilter struct {
	Search *string           `json:"search"`
	Where  *CommentLikeWhere `json:"where"`
}

type CommentLikeOrdering struct {
	Sort      CommentLikeSort `json:"sort"`
	Direction SortDirection   `json:"direction"`
}

type CommentLikePayload struct {
	CommentLike *CommentLike `json:"commentLike"`
}

type CommentLikeUpdateInput struct {
	CommentID *string `json:"commentId"`
	UserID    *string `json:"userId"`
	LikeType  *string `json:"likeType"`
	CreatedAt *int    `json:"createdAt"`
}

type CommentLikeWhere struct {
	ID        *IDFilter         `json:"id"`
	Comment   *CommentWhere     `json:"comment"`
	User      *UserWhere        `json:"user"`
	LikeType  *StringFilter     `json:"likeType"`
	CreatedAt *IntFilter        `json:"createdAt"`
	Or        *CommentLikeWhere `json:"or"`
	And       *CommentLikeWhere `json:"and"`
}

type CommentLikesCreateInput struct {
	CommentLikes []*CommentLikeCreateInput `json:"commentLikes"`
}

type CommentLikesDeletePayload struct {
	Ids []string `json:"ids"`
}

type CommentLikesPayload struct {
	CommentLikes []*CommentLike `json:"commentLikes"`
}

type CommentLikesUpdatePayload struct {
	Ok bool `json:"ok"`
}

type CommentOrdering struct {
	Sort      CommentSort   `json:"sort"`
	Direction SortDirection `json:"direction"`
}

type CommentPayload struct {
	Comment *Comment `json:"comment"`
}

type CommentUpdateInput struct {
	Content *string `json:"content"`
	PostID  *string `json:"postId"`
	UserID  *string `json:"userId"`
}

type CommentWhere struct {
	ID           *IDFilter         `json:"id"`
	Content      *StringFilter     `json:"content"`
	Post         *PostWhere        `json:"post"`
	User         *UserWhere        `json:"user"`
	CommentLikes *CommentLikeWhere `json:"commentLikes"`
	Or           *CommentWhere     `json:"or"`
	And          *CommentWhere     `json:"and"`
}

type CommentsCreateInput struct {
	Comments []*CommentCreateInput `json:"comments"`
}

type CommentsDeletePayload struct {
	Ids []string `json:"ids"`
}

type CommentsPayload struct {
	Comments []*Comment `json:"comments"`
}

type CommentsUpdatePayload struct {
	Ok bool `json:"ok"`
}

type ConnectionBackwardPagination struct {
	Last   int    `json:"last"`
	Before string `json:"before"`
}

type ConnectionForwardPagination struct {
	First int    `json:"first"`
	After string `json:"after"`
}

type ConnectionPagination struct {
	Forward  *ConnectionForwardPagination  `json:"forward"`
	Backward *ConnectionBackwardPagination `json:"backward"`
}

type FloatFilter struct {
	EqualTo           *float64  `json:"equalTo"`
	NotEqualTo        *float64  `json:"notEqualTo"`
	LessThan          *float64  `json:"lessThan"`
	LessThanOrEqualTo *float64  `json:"lessThanOrEqualTo"`
	MoreThan          *float64  `json:"moreThan"`
	MoreThanOrEqualTo *float64  `json:"moreThanOrEqualTo"`
	In                []float64 `json:"in"`
	NotIn             []float64 `json:"notIn"`
}

type Friendship struct {
	ID        string  `json:"id"`
	CreatedAt *int    `json:"createdAt"`
	Users     []*User `json:"users"`
}

func (Friendship) IsNode() {}

type FriendshipConnection struct {
	Edges    []*FriendshipEdge `json:"edges"`
	PageInfo *PageInfo         `json:"pageInfo"`
}

type FriendshipCreateInput struct {
	CreatedAt *int `json:"createdAt"`
}

type FriendshipDeletePayload struct {
	ID string `json:"id"`
}

type FriendshipEdge struct {
	Cursor string      `json:"cursor"`
	Node   *Friendship `json:"node"`
}

type FriendshipFilter struct {
	Search *string          `json:"search"`
	Where  *FriendshipWhere `json:"where"`
}

type FriendshipOrdering struct {
	Sort      FriendshipSort `json:"sort"`
	Direction SortDirection  `json:"direction"`
}

type FriendshipPayload struct {
	Friendship *Friendship `json:"friendship"`
}

type FriendshipUpdateInput struct {
	CreatedAt *int `json:"createdAt"`
}

type FriendshipWhere struct {
	ID        *IDFilter        `json:"id"`
	CreatedAt *IntFilter       `json:"createdAt"`
	Users     *UserWhere       `json:"users"`
	Or        *FriendshipWhere `json:"or"`
	And       *FriendshipWhere `json:"and"`
}

type FriendshipsCreateInput struct {
	Friendships []*FriendshipCreateInput `json:"friendships"`
}

type FriendshipsDeletePayload struct {
	Ids []string `json:"ids"`
}

type FriendshipsPayload struct {
	Friendships []*Friendship `json:"friendships"`
}

type FriendshipsUpdatePayload struct {
	Ok bool `json:"ok"`
}

type IDFilter struct {
	EqualTo    *string  `json:"equalTo"`
	NotEqualTo *string  `json:"notEqualTo"`
	In         []string `json:"in"`
	NotIn      []string `json:"notIn"`
}

type Image struct {
	ID              string            `json:"id"`
	Post            *Post             `json:"post"`
	Views           *int              `json:"views"`
	OriginalURL     *string           `json:"originalUrl"`
	ImageVariations []*ImageVariation `json:"imageVariations"`
}

func (Image) IsNode() {}

type ImageConnection struct {
	Edges    []*ImageEdge `json:"edges"`
	PageInfo *PageInfo    `json:"pageInfo"`
}

type ImageCreateInput struct {
	PostID      string  `json:"postId"`
	Views       *int    `json:"views"`
	OriginalURL *string `json:"originalUrl"`
}

type ImageDeletePayload struct {
	ID string `json:"id"`
}

type ImageEdge struct {
	Cursor string `json:"cursor"`
	Node   *Image `json:"node"`
}

type ImageFilter struct {
	Search *string     `json:"search"`
	Where  *ImageWhere `json:"where"`
}

type ImageOrdering struct {
	Sort      ImageSort     `json:"sort"`
	Direction SortDirection `json:"direction"`
}

type ImagePayload struct {
	Image *Image `json:"image"`
}

type ImageUpdateInput struct {
	PostID      *string `json:"postId"`
	Views       *int    `json:"views"`
	OriginalURL *string `json:"originalUrl"`
}

type ImageVariation struct {
	ID    string `json:"id"`
	Image *Image `json:"image"`
}

func (ImageVariation) IsNode() {}

type ImageVariationConnection struct {
	Edges    []*ImageVariationEdge `json:"edges"`
	PageInfo *PageInfo             `json:"pageInfo"`
}

type ImageVariationCreateInput struct {
	ImageID string `json:"imageId"`
}

type ImageVariationDeletePayload struct {
	ID string `json:"id"`
}

type ImageVariationEdge struct {
	Cursor string          `json:"cursor"`
	Node   *ImageVariation `json:"node"`
}

type ImageVariationFilter struct {
	Search *string              `json:"search"`
	Where  *ImageVariationWhere `json:"where"`
}

type ImageVariationOrdering struct {
	Sort      ImageVariationSort `json:"sort"`
	Direction SortDirection      `json:"direction"`
}

type ImageVariationPayload struct {
	ImageVariation *ImageVariation `json:"imageVariation"`
}

type ImageVariationUpdateInput struct {
	ImageID *string `json:"imageId"`
}

type ImageVariationWhere struct {
	ID    *IDFilter            `json:"id"`
	Image *ImageWhere          `json:"image"`
	Or    *ImageVariationWhere `json:"or"`
	And   *ImageVariationWhere `json:"and"`
}

type ImageVariationsCreateInput struct {
	ImageVariations []*ImageVariationCreateInput `json:"imageVariations"`
}

type ImageVariationsDeletePayload struct {
	Ids []string `json:"ids"`
}

type ImageVariationsPayload struct {
	ImageVariations []*ImageVariation `json:"imageVariations"`
}

type ImageVariationsUpdatePayload struct {
	Ok bool `json:"ok"`
}

type ImageWhere struct {
	ID              *IDFilter            `json:"id"`
	Post            *PostWhere           `json:"post"`
	Views           *IntFilter           `json:"views"`
	OriginalURL     *StringFilter        `json:"originalUrl"`
	ImageVariations *ImageVariationWhere `json:"imageVariations"`
	Or              *ImageWhere          `json:"or"`
	And             *ImageWhere          `json:"and"`
}

type ImagesCreateInput struct {
	Images []*ImageCreateInput `json:"images"`
}

type ImagesDeletePayload struct {
	Ids []string `json:"ids"`
}

type ImagesPayload struct {
	Images []*Image `json:"images"`
}

type ImagesUpdatePayload struct {
	Ok bool `json:"ok"`
}

type IntFilter struct {
	EqualTo           *int  `json:"equalTo"`
	NotEqualTo        *int  `json:"notEqualTo"`
	LessThan          *int  `json:"lessThan"`
	LessThanOrEqualTo *int  `json:"lessThanOrEqualTo"`
	MoreThan          *int  `json:"moreThan"`
	MoreThanOrEqualTo *int  `json:"moreThanOrEqualTo"`
	In                []int `json:"in"`
	NotIn             []int `json:"notIn"`
}

type Like struct {
	ID        string `json:"id"`
	Post      *Post  `json:"post"`
	User      *User  `json:"user"`
	LikeType  string `json:"likeType"`
	CreatedAt *int   `json:"createdAt"`
}

func (Like) IsNode() {}

type LikeConnection struct {
	Edges    []*LikeEdge `json:"edges"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

type LikeCreateInput struct {
	PostID    string `json:"postId"`
	UserID    string `json:"userId"`
	LikeType  string `json:"likeType"`
	CreatedAt *int   `json:"createdAt"`
}

type LikeDeletePayload struct {
	ID string `json:"id"`
}

type LikeEdge struct {
	Cursor string `json:"cursor"`
	Node   *Like  `json:"node"`
}

type LikeFilter struct {
	Search *string    `json:"search"`
	Where  *LikeWhere `json:"where"`
}

type LikeOrdering struct {
	Sort      LikeSort      `json:"sort"`
	Direction SortDirection `json:"direction"`
}

type LikePayload struct {
	Like *Like `json:"like"`
}

type LikeUpdateInput struct {
	PostID    *string `json:"postId"`
	UserID    *string `json:"userId"`
	LikeType  *string `json:"likeType"`
	CreatedAt *int    `json:"createdAt"`
}

type LikeWhere struct {
	ID        *IDFilter     `json:"id"`
	Post      *PostWhere    `json:"post"`
	User      *UserWhere    `json:"user"`
	LikeType  *StringFilter `json:"likeType"`
	CreatedAt *IntFilter    `json:"createdAt"`
	Or        *LikeWhere    `json:"or"`
	And       *LikeWhere    `json:"and"`
}

type LikesCreateInput struct {
	Likes []*LikeCreateInput `json:"likes"`
}

type LikesDeletePayload struct {
	Ids []string `json:"ids"`
}

type LikesPayload struct {
	Likes []*Like `json:"likes"`
}

type LikesUpdatePayload struct {
	Ok bool `json:"ok"`
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor"`
	EndCursor       *string `json:"endCursor"`
}

type Post struct {
	ID       string     `json:"id"`
	Content  string     `json:"content"`
	User     *User      `json:"user"`
	Comments []*Comment `json:"comments"`
	Images   []*Image   `json:"images"`
	Likes    []*Like    `json:"likes"`
}

func (Post) IsNode() {}

type PostConnection struct {
	Edges    []*PostEdge `json:"edges"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

type PostCreateInput struct {
	Content string `json:"content"`
	UserID  string `json:"userId"`
}

type PostDeletePayload struct {
	ID string `json:"id"`
}

type PostEdge struct {
	Cursor string `json:"cursor"`
	Node   *Post  `json:"node"`
}

type PostFilter struct {
	Search *string    `json:"search"`
	Where  *PostWhere `json:"where"`
}

type PostOrdering struct {
	Sort      PostSort      `json:"sort"`
	Direction SortDirection `json:"direction"`
}

type PostPayload struct {
	Post *Post `json:"post"`
}

type PostUpdateInput struct {
	Content *string `json:"content"`
	UserID  *string `json:"userId"`
}

type PostWhere struct {
	ID       *IDFilter     `json:"id"`
	Content  *StringFilter `json:"content"`
	User     *UserWhere    `json:"user"`
	Comments *CommentWhere `json:"comments"`
	Images   *ImageWhere   `json:"images"`
	Likes    *LikeWhere    `json:"likes"`
	Or       *PostWhere    `json:"or"`
	And      *PostWhere    `json:"and"`
}

type PostsCreateInput struct {
	Posts []*PostCreateInput `json:"posts"`
}

type PostsDeletePayload struct {
	Ids []string `json:"ids"`
}

type PostsPayload struct {
	Posts []*Post `json:"posts"`
}

type PostsUpdatePayload struct {
	Ok bool `json:"ok"`
}

type StringFilter struct {
	EqualTo            *string  `json:"equalTo"`
	NotEqualTo         *string  `json:"notEqualTo"`
	In                 []string `json:"in"`
	NotIn              []string `json:"notIn"`
	StartWith          *string  `json:"startWith"`
	NotStartWith       *string  `json:"notStartWith"`
	EndWith            *string  `json:"endWith"`
	NotEndWith         *string  `json:"notEndWith"`
	Contain            *string  `json:"contain"`
	NotContain         *string  `json:"notContain"`
	StartWithStrict    *string  `json:"startWithStrict"`
	NotStartWithStrict *string  `json:"notStartWithStrict"`
	EndWithStrict      *string  `json:"endWithStrict"`
	NotEndWithStrict   *string  `json:"notEndWithStrict"`
	ContainStrict      *string  `json:"containStrict"`
	NotContainStrict   *string  `json:"notContainStrict"`
}

type User struct {
	ID           string         `json:"id"`
	FirstName    string         `json:"firstName"`
	LastName     string         `json:"lastName"`
	Email        string         `json:"email"`
	Comments     []*Comment     `json:"comments"`
	CommentLikes []*CommentLike `json:"commentLikes"`
	Likes        []*Like        `json:"likes"`
	Posts        []*Post        `json:"posts"`
	Friendships  []*Friendship  `json:"friendships"`
}

func (User) IsNode() {}

type UserConnection struct {
	Edges    []*UserEdge `json:"edges"`
	PageInfo *PageInfo   `json:"pageInfo"`
}

type UserCreateInput struct {
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	Email     string `json:"email"`
}

type UserDeletePayload struct {
	ID string `json:"id"`
}

type UserEdge struct {
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
}

type UserFilter struct {
	Search *string    `json:"search"`
	Where  *UserWhere `json:"where"`
}

type UserOrdering struct {
	Sort      UserSort      `json:"sort"`
	Direction SortDirection `json:"direction"`
}

type UserPayload struct {
	User *User `json:"user"`
}

type UserUpdateInput struct {
	FirstName *string `json:"firstName"`
	LastName  *string `json:"lastName"`
	Email     *string `json:"email"`
}

type UserWhere struct {
	ID           *IDFilter         `json:"id"`
	FirstName    *StringFilter     `json:"firstName"`
	LastName     *StringFilter     `json:"lastName"`
	Email        *StringFilter     `json:"email"`
	Comments     *CommentWhere     `json:"comments"`
	CommentLikes *CommentLikeWhere `json:"commentLikes"`
	Likes        *LikeWhere        `json:"likes"`
	Posts        *PostWhere        `json:"posts"`
	Friendships  *FriendshipWhere  `json:"friendships"`
	Or           *UserWhere        `json:"or"`
	And          *UserWhere        `json:"and"`
}

type UsersCreateInput struct {
	Users []*UserCreateInput `json:"users"`
}

type UsersDeletePayload struct {
	Ids []string `json:"ids"`
}

type UsersPayload struct {
	Users []*User `json:"users"`
}

type UsersUpdatePayload struct {
	Ok bool `json:"ok"`
}

type CommentLikeSort string

const (
	CommentLikeSortID        CommentLikeSort = "ID"
	CommentLikeSortLikeType  CommentLikeSort = "LIKE_TYPE"
	CommentLikeSortCreatedAt CommentLikeSort = "CREATED_AT"
)

var AllCommentLikeSort = []CommentLikeSort{
	CommentLikeSortID,
	CommentLikeSortLikeType,
	CommentLikeSortCreatedAt,
}

func (e CommentLikeSort) IsValid() bool {
	switch e {
	case CommentLikeSortID, CommentLikeSortLikeType, CommentLikeSortCreatedAt:
		return true
	}
	return false
}

func (e CommentLikeSort) String() string {
	return string(e)
}

func (e *CommentLikeSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentLikeSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentLikeSort", str)
	}
	return nil
}

func (e CommentLikeSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentSort string

const (
	CommentSortID      CommentSort = "ID"
	CommentSortContent CommentSort = "CONTENT"
)

var AllCommentSort = []CommentSort{
	CommentSortID,
	CommentSortContent,
}

func (e CommentSort) IsValid() bool {
	switch e {
	case CommentSortID, CommentSortContent:
		return true
	}
	return false
}

func (e CommentSort) String() string {
	return string(e)
}

func (e *CommentSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentSort", str)
	}
	return nil
}

func (e CommentSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FriendshipSort string

const (
	FriendshipSortID        FriendshipSort = "ID"
	FriendshipSortCreatedAt FriendshipSort = "CREATED_AT"
)

var AllFriendshipSort = []FriendshipSort{
	FriendshipSortID,
	FriendshipSortCreatedAt,
}

func (e FriendshipSort) IsValid() bool {
	switch e {
	case FriendshipSortID, FriendshipSortCreatedAt:
		return true
	}
	return false
}

func (e FriendshipSort) String() string {
	return string(e)
}

func (e *FriendshipSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FriendshipSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FriendshipSort", str)
	}
	return nil
}

func (e FriendshipSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageSort string

const (
	ImageSortID          ImageSort = "ID"
	ImageSortViews       ImageSort = "VIEWS"
	ImageSortOriginalURL ImageSort = "ORIGINAL_URL"
)

var AllImageSort = []ImageSort{
	ImageSortID,
	ImageSortViews,
	ImageSortOriginalURL,
}

func (e ImageSort) IsValid() bool {
	switch e {
	case ImageSortID, ImageSortViews, ImageSortOriginalURL:
		return true
	}
	return false
}

func (e ImageSort) String() string {
	return string(e)
}

func (e *ImageSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageSort", str)
	}
	return nil
}

func (e ImageSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ImageVariationSort string

const (
	ImageVariationSortID ImageVariationSort = "ID"
)

var AllImageVariationSort = []ImageVariationSort{
	ImageVariationSortID,
}

func (e ImageVariationSort) IsValid() bool {
	switch e {
	case ImageVariationSortID:
		return true
	}
	return false
}

func (e ImageVariationSort) String() string {
	return string(e)
}

func (e *ImageVariationSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageVariationSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageVariationSort", str)
	}
	return nil
}

func (e ImageVariationSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LikeSort string

const (
	LikeSortID        LikeSort = "ID"
	LikeSortLikeType  LikeSort = "LIKE_TYPE"
	LikeSortCreatedAt LikeSort = "CREATED_AT"
)

var AllLikeSort = []LikeSort{
	LikeSortID,
	LikeSortLikeType,
	LikeSortCreatedAt,
}

func (e LikeSort) IsValid() bool {
	switch e {
	case LikeSortID, LikeSortLikeType, LikeSortCreatedAt:
		return true
	}
	return false
}

func (e LikeSort) String() string {
	return string(e)
}

func (e *LikeSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LikeSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LikeSort", str)
	}
	return nil
}

func (e LikeSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PostSort string

const (
	PostSortID      PostSort = "ID"
	PostSortContent PostSort = "CONTENT"
)

var AllPostSort = []PostSort{
	PostSortID,
	PostSortContent,
}

func (e PostSort) IsValid() bool {
	switch e {
	case PostSortID, PostSortContent:
		return true
	}
	return false
}

func (e PostSort) String() string {
	return string(e)
}

func (e *PostSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostSort", str)
	}
	return nil
}

func (e PostSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserSort string

const (
	UserSortID        UserSort = "ID"
	UserSortFirstName UserSort = "FIRST_NAME"
	UserSortLastName  UserSort = "LAST_NAME"
	UserSortEmail     UserSort = "EMAIL"
)

var AllUserSort = []UserSort{
	UserSortID,
	UserSortFirstName,
	UserSortLastName,
	UserSortEmail,
}

func (e UserSort) IsValid() bool {
	switch e {
	case UserSortID, UserSortFirstName, UserSortLastName, UserSortEmail:
		return true
	}
	return false
}

func (e UserSort) String() string {
	return string(e)
}

func (e *UserSort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserSort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserSort", str)
	}
	return nil
}

func (e UserSort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
