// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
	null "github.com/volatiletech/null/v8"
	"github.com/web-ridge/gqlgen-sqlboiler-examples/issue-38-plugin-panics/graphql_models"
	"github.com/web-ridge/gqlgen-sqlboiler-examples/issue-38-plugin-panics/models"
	"github.com/web-ridge/utils-go/boilergql"
)

func AdditiveWithUintID(id uint) *graphql_models.Additive {
	return &graphql_models.Additive{
		ID: AdditiveIDToGraphQL(id),
	}
}

func AdditiveWithIntID(id int) *graphql_models.Additive {
	return AdditiveWithUintID(uint(id))
}

func AdditiveWithNullDotUintID(id null.Uint) *graphql_models.Additive {
	return AdditiveWithUintID(id.Uint)
}

func AdditiveWithNullDotIntID(id null.Int) *graphql_models.Additive {
	return AdditiveWithUintID(uint(id.Int))
}

func AdditivesToGraphQL(am []*models.Additive) []*graphql_models.Additive {
	ar := make([]*graphql_models.Additive, len(am))
	for i, m := range am {
		ar[i] = AdditiveToGraphQL(m)
	}
	return ar
}

func AdditiveIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.Additive)
}

func AdditiveToGraphQL(m *models.Additive) *graphql_models.Additive {
	if m == nil {
		return nil
	}

	r := &graphql_models.Additive{

		ID:        AdditiveIDToGraphQL(uint(m.ID)),
		Name:      m.Name,
		Note:      m.Note,
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
	}

	if m.R != nil && m.R.RecipeAdditive != nil {
		r.RecipeAdditive = RecipeAdditiveToGraphQL(m.R.RecipeAdditive)
	}
	if m.R != nil && m.R.RecipeBatchAdditive != nil {
		r.RecipeBatchAdditive = RecipeBatchAdditiveToGraphQL(m.R.RecipeBatchAdditive)
	}
	if m.R != nil && m.R.AdditiveInventories != nil {
		r.AdditiveInventories = AdditiveInventoriesToGraphQL(m.R.AdditiveInventories)
	}

	return r
}

func AdditiveID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AdditiveIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AdditiveInventoryWithUintID(id uint) *graphql_models.AdditiveInventory {
	return &graphql_models.AdditiveInventory{
		ID: AdditiveInventoryIDToGraphQL(id),
	}
}

func AdditiveInventoryWithIntID(id int) *graphql_models.AdditiveInventory {
	return AdditiveInventoryWithUintID(uint(id))
}

func AdditiveInventoryWithNullDotUintID(id null.Uint) *graphql_models.AdditiveInventory {
	return AdditiveInventoryWithUintID(id.Uint)
}

func AdditiveInventoryWithNullDotIntID(id null.Int) *graphql_models.AdditiveInventory {
	return AdditiveInventoryWithUintID(uint(id.Int))
}

func AdditiveInventoriesToGraphQL(am []*models.AdditiveInventory) []*graphql_models.AdditiveInventory {
	ar := make([]*graphql_models.AdditiveInventory, len(am))
	for i, m := range am {
		ar[i] = AdditiveInventoryToGraphQL(m)
	}
	return ar
}

func AdditiveInventoryIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AdditiveInventory)
}

func AdditiveInventoryToGraphQL(m *models.AdditiveInventory) *graphql_models.AdditiveInventory {
	if m == nil {
		return nil
	}

	r := &graphql_models.AdditiveInventory{

		ID:           AdditiveInventoryIDToGraphQL(uint(m.ID)),
		PurchaseDate: boilergql.TimeDotTimeToInt(m.PurchaseDate),
		ExpiryDate:   boilergql.TimeDotTimeToInt(m.ExpiryDate),
		Cost:         m.Cost,
		Weight:       m.Weight,
		UpdatedAt:    boilergql.TimeDotTimeToInt(m.UpdatedAt),
		DeletedAt:    boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt:    boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if boilergql.IntIsFilled(m.AdditiveID) {
		if m.R != nil && m.R.Additive != nil {
			r.Additive = AdditiveToGraphQL(m.R.Additive)
		} else {
			r.Additive = AdditiveWithIntID(m.AdditiveID)
		}
	}
	if boilergql.IntIsFilled(m.SupplierID) {
		if m.R != nil && m.R.Supplier != nil {
			r.Supplier = SupplierToGraphQL(m.R.Supplier)
		} else {
			r.Supplier = SupplierWithIntID(m.SupplierID)
		}
	}

	return r
}

func AdditiveInventoryID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AdditiveInventoryIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AuthGroupWithUintID(id uint) *graphql_models.AuthGroup {
	return &graphql_models.AuthGroup{
		ID: AuthGroupIDToGraphQL(id),
	}
}

func AuthGroupWithIntID(id int) *graphql_models.AuthGroup {
	return AuthGroupWithUintID(uint(id))
}

func AuthGroupWithNullDotUintID(id null.Uint) *graphql_models.AuthGroup {
	return AuthGroupWithUintID(id.Uint)
}

func AuthGroupWithNullDotIntID(id null.Int) *graphql_models.AuthGroup {
	return AuthGroupWithUintID(uint(id.Int))
}

func AuthGroupsToGraphQL(am []*models.AuthGroup) []*graphql_models.AuthGroup {
	ar := make([]*graphql_models.AuthGroup, len(am))
	for i, m := range am {
		ar[i] = AuthGroupToGraphQL(m)
	}
	return ar
}

func AuthGroupIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AuthGroup)
}

func AuthGroupToGraphQL(m *models.AuthGroup) *graphql_models.AuthGroup {
	if m == nil {
		return nil
	}

	r := &graphql_models.AuthGroup{

		ID:   AuthGroupIDToGraphQL(uint(m.ID)),
		Name: m.Name,
	}

	if m.R != nil && m.R.GroupAuthGroupPermissions != nil {
		r.GroupAuthGroupPermissions = AuthGroupPermissionsToGraphQL(m.R.GroupAuthGroupPermissions)
	}
	if m.R != nil && m.R.GroupAuthUserGroups != nil {
		r.GroupAuthUserGroups = AuthUserGroupsToGraphQL(m.R.GroupAuthUserGroups)
	}

	return r
}

func AuthGroupID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AuthGroupIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AuthGroupPermissionWithUintID(id uint) *graphql_models.AuthGroupPermission {
	return &graphql_models.AuthGroupPermission{
		ID: AuthGroupPermissionIDToGraphQL(id),
	}
}

func AuthGroupPermissionWithIntID(id int) *graphql_models.AuthGroupPermission {
	return AuthGroupPermissionWithUintID(uint(id))
}

func AuthGroupPermissionWithNullDotUintID(id null.Uint) *graphql_models.AuthGroupPermission {
	return AuthGroupPermissionWithUintID(id.Uint)
}

func AuthGroupPermissionWithNullDotIntID(id null.Int) *graphql_models.AuthGroupPermission {
	return AuthGroupPermissionWithUintID(uint(id.Int))
}

func AuthGroupPermissionsToGraphQL(am []*models.AuthGroupPermission) []*graphql_models.AuthGroupPermission {
	ar := make([]*graphql_models.AuthGroupPermission, len(am))
	for i, m := range am {
		ar[i] = AuthGroupPermissionToGraphQL(m)
	}
	return ar
}

func AuthGroupPermissionIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AuthGroupPermissions)
}

func AuthGroupPermissionToGraphQL(m *models.AuthGroupPermission) *graphql_models.AuthGroupPermission {
	if m == nil {
		return nil
	}

	r := &graphql_models.AuthGroupPermission{

		ID: AuthGroupPermissionIDToGraphQL(uint(m.ID)),
	}

	if boilergql.IntIsFilled(m.GroupID) {
		if m.R != nil && m.R.Group != nil {
			r.Group = AuthGroupToGraphQL(m.R.Group)
		} else {
			r.Group = AuthGroupWithIntID(m.GroupID)
		}
	}
	if boilergql.IntIsFilled(m.PermissionID) {
		if m.R != nil && m.R.Permission != nil {
			r.Permission = AuthPermissionToGraphQL(m.R.Permission)
		} else {
			r.Permission = AuthPermissionWithIntID(m.PermissionID)
		}
	}

	return r
}

func AuthGroupPermissionID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AuthGroupPermissionIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AuthPermissionWithUintID(id uint) *graphql_models.AuthPermission {
	return &graphql_models.AuthPermission{
		ID: AuthPermissionIDToGraphQL(id),
	}
}

func AuthPermissionWithIntID(id int) *graphql_models.AuthPermission {
	return AuthPermissionWithUintID(uint(id))
}

func AuthPermissionWithNullDotUintID(id null.Uint) *graphql_models.AuthPermission {
	return AuthPermissionWithUintID(id.Uint)
}

func AuthPermissionWithNullDotIntID(id null.Int) *graphql_models.AuthPermission {
	return AuthPermissionWithUintID(uint(id.Int))
}

func AuthPermissionsToGraphQL(am []*models.AuthPermission) []*graphql_models.AuthPermission {
	ar := make([]*graphql_models.AuthPermission, len(am))
	for i, m := range am {
		ar[i] = AuthPermissionToGraphQL(m)
	}
	return ar
}

func AuthPermissionIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AuthPermission)
}

func AuthPermissionToGraphQL(m *models.AuthPermission) *graphql_models.AuthPermission {
	if m == nil {
		return nil
	}

	r := &graphql_models.AuthPermission{

		ID:            AuthPermissionIDToGraphQL(uint(m.ID)),
		Name:          m.Name,
		ContentTypeID: boilergql.IntToString(m.ContentTypeID),
		Codename:      m.Codename,
	}

	if m.R != nil && m.R.PermissionAuthGroupPermissions != nil {
		r.PermissionAuthGroupPermissions = AuthGroupPermissionsToGraphQL(m.R.PermissionAuthGroupPermissions)
	}
	if m.R != nil && m.R.PermissionAuthUserUserPermissions != nil {
		r.PermissionAuthUserUserPermissions = AuthUserUserPermissionsToGraphQL(m.R.PermissionAuthUserUserPermissions)
	}

	return r
}

func AuthPermissionID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AuthPermissionIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AuthUserWithUintID(id uint) *graphql_models.AuthUser {
	return &graphql_models.AuthUser{
		ID: AuthUserIDToGraphQL(id),
	}
}

func AuthUserWithIntID(id int) *graphql_models.AuthUser {
	return AuthUserWithUintID(uint(id))
}

func AuthUserWithNullDotUintID(id null.Uint) *graphql_models.AuthUser {
	return AuthUserWithUintID(id.Uint)
}

func AuthUserWithNullDotIntID(id null.Int) *graphql_models.AuthUser {
	return AuthUserWithUintID(uint(id.Int))
}

func AuthUsersToGraphQL(am []*models.AuthUser) []*graphql_models.AuthUser {
	ar := make([]*graphql_models.AuthUser, len(am))
	for i, m := range am {
		ar[i] = AuthUserToGraphQL(m)
	}
	return ar
}

func AuthUserIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AuthUser)
}

func AuthUserToGraphQL(m *models.AuthUser) *graphql_models.AuthUser {
	if m == nil {
		return nil
	}

	r := &graphql_models.AuthUser{

		ID:          AuthUserIDToGraphQL(uint(m.ID)),
		Password:    m.Password,
		LastLogin:   boilergql.NullDotTimeToPointerInt(m.LastLogin),
		IsSuperuser: m.IsSuperuser,
		Username:    m.Username,
		FirstName:   m.FirstName,
		LastName:    m.LastName,
		Email:       m.Email,
		IsStaff:     m.IsStaff,
		IsActive:    m.IsActive,
		DateJoined:  boilergql.TimeDotTimeToInt(m.DateJoined),
	}

	if m.R != nil && m.R.UserAuthUserGroups != nil {
		r.UserAuthUserGroups = AuthUserGroupsToGraphQL(m.R.UserAuthUserGroups)
	}
	if m.R != nil && m.R.UserAuthUserUserPermissions != nil {
		r.UserAuthUserUserPermissions = AuthUserUserPermissionsToGraphQL(m.R.UserAuthUserUserPermissions)
	}

	return r
}

func AuthUserID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AuthUserIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AuthUserGroupWithUintID(id uint) *graphql_models.AuthUserGroup {
	return &graphql_models.AuthUserGroup{
		ID: AuthUserGroupIDToGraphQL(id),
	}
}

func AuthUserGroupWithIntID(id int) *graphql_models.AuthUserGroup {
	return AuthUserGroupWithUintID(uint(id))
}

func AuthUserGroupWithNullDotUintID(id null.Uint) *graphql_models.AuthUserGroup {
	return AuthUserGroupWithUintID(id.Uint)
}

func AuthUserGroupWithNullDotIntID(id null.Int) *graphql_models.AuthUserGroup {
	return AuthUserGroupWithUintID(uint(id.Int))
}

func AuthUserGroupsToGraphQL(am []*models.AuthUserGroup) []*graphql_models.AuthUserGroup {
	ar := make([]*graphql_models.AuthUserGroup, len(am))
	for i, m := range am {
		ar[i] = AuthUserGroupToGraphQL(m)
	}
	return ar
}

func AuthUserGroupIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AuthUserGroups)
}

func AuthUserGroupToGraphQL(m *models.AuthUserGroup) *graphql_models.AuthUserGroup {
	if m == nil {
		return nil
	}

	r := &graphql_models.AuthUserGroup{

		ID: AuthUserGroupIDToGraphQL(uint(m.ID)),
	}

	if boilergql.IntIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			r.User = AuthUserToGraphQL(m.R.User)
		} else {
			r.User = AuthUserWithIntID(m.UserID)
		}
	}
	if boilergql.IntIsFilled(m.GroupID) {
		if m.R != nil && m.R.Group != nil {
			r.Group = AuthGroupToGraphQL(m.R.Group)
		} else {
			r.Group = AuthGroupWithIntID(m.GroupID)
		}
	}

	return r
}

func AuthUserGroupID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AuthUserGroupIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func AuthUserUserPermissionWithUintID(id uint) *graphql_models.AuthUserUserPermission {
	return &graphql_models.AuthUserUserPermission{
		ID: AuthUserUserPermissionIDToGraphQL(id),
	}
}

func AuthUserUserPermissionWithIntID(id int) *graphql_models.AuthUserUserPermission {
	return AuthUserUserPermissionWithUintID(uint(id))
}

func AuthUserUserPermissionWithNullDotUintID(id null.Uint) *graphql_models.AuthUserUserPermission {
	return AuthUserUserPermissionWithUintID(id.Uint)
}

func AuthUserUserPermissionWithNullDotIntID(id null.Int) *graphql_models.AuthUserUserPermission {
	return AuthUserUserPermissionWithUintID(uint(id.Int))
}

func AuthUserUserPermissionsToGraphQL(am []*models.AuthUserUserPermission) []*graphql_models.AuthUserUserPermission {
	ar := make([]*graphql_models.AuthUserUserPermission, len(am))
	for i, m := range am {
		ar[i] = AuthUserUserPermissionToGraphQL(m)
	}
	return ar
}

func AuthUserUserPermissionIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.AuthUserUserPermissions)
}

func AuthUserUserPermissionToGraphQL(m *models.AuthUserUserPermission) *graphql_models.AuthUserUserPermission {
	if m == nil {
		return nil
	}

	r := &graphql_models.AuthUserUserPermission{

		ID: AuthUserUserPermissionIDToGraphQL(uint(m.ID)),
	}

	if boilergql.IntIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			r.User = AuthUserToGraphQL(m.R.User)
		} else {
			r.User = AuthUserWithIntID(m.UserID)
		}
	}
	if boilergql.IntIsFilled(m.PermissionID) {
		if m.R != nil && m.R.Permission != nil {
			r.Permission = AuthPermissionToGraphQL(m.R.Permission)
		} else {
			r.Permission = AuthPermissionWithIntID(m.PermissionID)
		}
	}

	return r
}

func AuthUserUserPermissionID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func AuthUserUserPermissionIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func FragranceWithUintID(id uint) *graphql_models.Fragrance {
	return &graphql_models.Fragrance{
		ID: FragranceIDToGraphQL(id),
	}
}

func FragranceWithIntID(id int) *graphql_models.Fragrance {
	return FragranceWithUintID(uint(id))
}

func FragranceWithNullDotUintID(id null.Uint) *graphql_models.Fragrance {
	return FragranceWithUintID(id.Uint)
}

func FragranceWithNullDotIntID(id null.Int) *graphql_models.Fragrance {
	return FragranceWithUintID(uint(id.Int))
}

func FragrancesToGraphQL(am []*models.Fragrance) []*graphql_models.Fragrance {
	ar := make([]*graphql_models.Fragrance, len(am))
	for i, m := range am {
		ar[i] = FragranceToGraphQL(m)
	}
	return ar
}

func FragranceIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.Fragrance)
}

func FragranceToGraphQL(m *models.Fragrance) *graphql_models.Fragrance {
	if m == nil {
		return nil
	}

	r := &graphql_models.Fragrance{

		ID:        FragranceIDToGraphQL(uint(m.ID)),
		Name:      m.Name,
		Note:      m.Note,
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if m.R != nil && m.R.RecipeBatchFragrance != nil {
		r.RecipeBatchFragrance = RecipeBatchFragranceToGraphQL(m.R.RecipeBatchFragrance)
	}
	if m.R != nil && m.R.RecipeFragrance != nil {
		r.RecipeFragrance = RecipeFragranceToGraphQL(m.R.RecipeFragrance)
	}
	if m.R != nil && m.R.FragranceInventories != nil {
		r.FragranceInventories = FragranceInventoriesToGraphQL(m.R.FragranceInventories)
	}

	return r
}

func FragranceID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func FragranceIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func FragranceInventoryWithUintID(id uint) *graphql_models.FragranceInventory {
	return &graphql_models.FragranceInventory{
		ID: FragranceInventoryIDToGraphQL(id),
	}
}

func FragranceInventoryWithIntID(id int) *graphql_models.FragranceInventory {
	return FragranceInventoryWithUintID(uint(id))
}

func FragranceInventoryWithNullDotUintID(id null.Uint) *graphql_models.FragranceInventory {
	return FragranceInventoryWithUintID(id.Uint)
}

func FragranceInventoryWithNullDotIntID(id null.Int) *graphql_models.FragranceInventory {
	return FragranceInventoryWithUintID(uint(id.Int))
}

func FragranceInventoriesToGraphQL(am []*models.FragranceInventory) []*graphql_models.FragranceInventory {
	ar := make([]*graphql_models.FragranceInventory, len(am))
	for i, m := range am {
		ar[i] = FragranceInventoryToGraphQL(m)
	}
	return ar
}

func FragranceInventoryIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.FragranceInventory)
}

func FragranceInventoryToGraphQL(m *models.FragranceInventory) *graphql_models.FragranceInventory {
	if m == nil {
		return nil
	}

	r := &graphql_models.FragranceInventory{

		ID:           FragranceInventoryIDToGraphQL(uint(m.ID)),
		PurchaseDate: boilergql.TimeDotTimeToInt(m.PurchaseDate),
		ExpiryDate:   boilergql.TimeDotTimeToInt(m.ExpiryDate),
		Cost:         m.Cost,
		Weight:       m.Weight,
		CreatedAt:    boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt:    boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt:    boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if boilergql.IntIsFilled(m.FragranceID) {
		if m.R != nil && m.R.Fragrance != nil {
			r.Fragrance = FragranceToGraphQL(m.R.Fragrance)
		} else {
			r.Fragrance = FragranceWithIntID(m.FragranceID)
		}
	}
	if boilergql.IntIsFilled(m.SupplierID) {
		if m.R != nil && m.R.Supplier != nil {
			r.Supplier = SupplierToGraphQL(m.R.Supplier)
		} else {
			r.Supplier = SupplierWithIntID(m.SupplierID)
		}
	}

	return r
}

func FragranceInventoryID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func FragranceInventoryIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func LipidWithUintID(id uint) *graphql_models.Lipid {
	return &graphql_models.Lipid{
		ID: LipidIDToGraphQL(id),
	}
}

func LipidWithIntID(id int) *graphql_models.Lipid {
	return LipidWithUintID(uint(id))
}

func LipidWithNullDotUintID(id null.Uint) *graphql_models.Lipid {
	return LipidWithUintID(id.Uint)
}

func LipidWithNullDotIntID(id null.Int) *graphql_models.Lipid {
	return LipidWithUintID(uint(id.Int))
}

func LipidsToGraphQL(am []*models.Lipid) []*graphql_models.Lipid {
	ar := make([]*graphql_models.Lipid, len(am))
	for i, m := range am {
		ar[i] = LipidToGraphQL(m)
	}
	return ar
}

func LipidIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.Lipid)
}

func LipidToGraphQL(m *models.Lipid) *graphql_models.Lipid {
	if m == nil {
		return nil
	}

	r := &graphql_models.Lipid{

		ID:           LipidIDToGraphQL(uint(m.ID)),
		Name:         m.Name,
		Lauric:       m.Lauric,
		Myristic:     m.Myristic,
		Palmitic:     m.Palmitic,
		Stearic:      m.Stearic,
		Ricinoleic:   m.Ricinoleic,
		Oleic:        m.Oleic,
		Linoleic:     m.Linoleic,
		Linolenic:    m.Linolenic,
		Hardness:     m.Hardness,
		Cleansing:    m.Cleansing,
		Conditioning: m.Conditioning,
		Bubbly:       m.Bubbly,
		Creamy:       m.Creamy,
		Iodine:       m.Iodine,
		Ins:          m.Ins,
		InciName:     m.InciName,
		Family:       m.Family,
		Naoh:         m.Naoh,
		DeletedAt:    boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt:    boilergql.TimeDotTimeToInt(m.CreatedAt),
		UpdatedAt:    boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if m.R != nil && m.R.RecipeBatchLipid != nil {
		r.RecipeBatchLipid = RecipeBatchLipidToGraphQL(m.R.RecipeBatchLipid)
	}
	if m.R != nil && m.R.RecipeLipid != nil {
		r.RecipeLipid = RecipeLipidToGraphQL(m.R.RecipeLipid)
	}
	if m.R != nil && m.R.LipidInventories != nil {
		r.LipidInventories = LipidInventoriesToGraphQL(m.R.LipidInventories)
	}

	return r
}

func LipidID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func LipidIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func LipidInventoryWithUintID(id uint) *graphql_models.LipidInventory {
	return &graphql_models.LipidInventory{
		ID: LipidInventoryIDToGraphQL(id),
	}
}

func LipidInventoryWithIntID(id int) *graphql_models.LipidInventory {
	return LipidInventoryWithUintID(uint(id))
}

func LipidInventoryWithNullDotUintID(id null.Uint) *graphql_models.LipidInventory {
	return LipidInventoryWithUintID(id.Uint)
}

func LipidInventoryWithNullDotIntID(id null.Int) *graphql_models.LipidInventory {
	return LipidInventoryWithUintID(uint(id.Int))
}

func LipidInventoriesToGraphQL(am []*models.LipidInventory) []*graphql_models.LipidInventory {
	ar := make([]*graphql_models.LipidInventory, len(am))
	for i, m := range am {
		ar[i] = LipidInventoryToGraphQL(m)
	}
	return ar
}

func LipidInventoryIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.LipidInventory)
}

func LipidInventoryToGraphQL(m *models.LipidInventory) *graphql_models.LipidInventory {
	if m == nil {
		return nil
	}

	r := &graphql_models.LipidInventory{

		ID:            LipidInventoryIDToGraphQL(uint(m.ID)),
		PurchaseDate:  boilergql.TimeDotTimeToInt(m.PurchaseDate),
		ExpiryDate:    boilergql.TimeDotTimeToInt(m.ExpiryDate),
		Cost:          m.Cost,
		Weight:        m.Weight,
		Sap:           m.Sap,
		Naoh:          m.Naoh,
		Koh:           m.Koh,
		GramsPerLiter: m.GramsPerLiter,
		DeletedAt:     boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt:     boilergql.TimeDotTimeToInt(m.UpdatedAt),
		CreatedAt:     boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if boilergql.IntIsFilled(m.LipidID) {
		if m.R != nil && m.R.Lipid != nil {
			r.Lipid = LipidToGraphQL(m.R.Lipid)
		} else {
			r.Lipid = LipidWithIntID(m.LipidID)
		}
	}
	if boilergql.IntIsFilled(m.SupplierID) {
		if m.R != nil && m.R.Supplier != nil {
			r.Supplier = SupplierToGraphQL(m.R.Supplier)
		} else {
			r.Supplier = SupplierWithIntID(m.SupplierID)
		}
	}

	return r
}

func LipidInventoryID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func LipidInventoryIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func LyeWithUintID(id uint) *graphql_models.Lye {
	return &graphql_models.Lye{
		ID: LyeIDToGraphQL(id),
	}
}

func LyeWithIntID(id int) *graphql_models.Lye {
	return LyeWithUintID(uint(id))
}

func LyeWithNullDotUintID(id null.Uint) *graphql_models.Lye {
	return LyeWithUintID(id.Uint)
}

func LyeWithNullDotIntID(id null.Int) *graphql_models.Lye {
	return LyeWithUintID(uint(id.Int))
}

func LyesToGraphQL(am []*models.Lye) []*graphql_models.Lye {
	ar := make([]*graphql_models.Lye, len(am))
	for i, m := range am {
		ar[i] = LyeToGraphQL(m)
	}
	return ar
}

func LyeIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.Lye)
}

func LyeToGraphQL(m *models.Lye) *graphql_models.Lye {
	if m == nil {
		return nil
	}

	r := &graphql_models.Lye{

		ID:        LyeIDToGraphQL(uint(m.ID)),
		Kind:      m.Kind,
		Name:      m.Name,
		Note:      m.Note,
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if m.R != nil && m.R.RecipeBatchLye != nil {
		r.RecipeBatchLye = RecipeBatchLyeToGraphQL(m.R.RecipeBatchLye)
	}
	if m.R != nil && m.R.LyeInventories != nil {
		r.LyeInventories = LyeInventoriesToGraphQL(m.R.LyeInventories)
	}

	return r
}

func LyeID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func LyeIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func LyeInventoryWithUintID(id uint) *graphql_models.LyeInventory {
	return &graphql_models.LyeInventory{
		ID: LyeInventoryIDToGraphQL(id),
	}
}

func LyeInventoryWithIntID(id int) *graphql_models.LyeInventory {
	return LyeInventoryWithUintID(uint(id))
}

func LyeInventoryWithNullDotUintID(id null.Uint) *graphql_models.LyeInventory {
	return LyeInventoryWithUintID(id.Uint)
}

func LyeInventoryWithNullDotIntID(id null.Int) *graphql_models.LyeInventory {
	return LyeInventoryWithUintID(uint(id.Int))
}

func LyeInventoriesToGraphQL(am []*models.LyeInventory) []*graphql_models.LyeInventory {
	ar := make([]*graphql_models.LyeInventory, len(am))
	for i, m := range am {
		ar[i] = LyeInventoryToGraphQL(m)
	}
	return ar
}

func LyeInventoryIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.LyeInventory)
}

func LyeInventoryToGraphQL(m *models.LyeInventory) *graphql_models.LyeInventory {
	if m == nil {
		return nil
	}

	r := &graphql_models.LyeInventory{

		ID:            LyeInventoryIDToGraphQL(uint(m.ID)),
		PurchaseDate:  boilergql.TimeDotTimeToInt(m.PurchaseDate),
		ExpiryDate:    boilergql.TimeDotTimeToInt(m.ExpiryDate),
		Cost:          m.Cost,
		Weight:        m.Weight,
		Concentration: m.Concentration,
		DeletedAt:     boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt:     boilergql.TimeDotTimeToInt(m.UpdatedAt),
		CreatedAt:     boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if boilergql.IntIsFilled(m.LyeID) {
		if m.R != nil && m.R.Lye != nil {
			r.Lye = LyeToGraphQL(m.R.Lye)
		} else {
			r.Lye = LyeWithIntID(m.LyeID)
		}
	}
	if boilergql.IntIsFilled(m.SupplierID) {
		if m.R != nil && m.R.Supplier != nil {
			r.Supplier = SupplierToGraphQL(m.R.Supplier)
		} else {
			r.Supplier = SupplierWithIntID(m.SupplierID)
		}
	}

	return r
}

func LyeInventoryID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func LyeInventoryIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeWithUintID(id uint) *graphql_models.Recipe {
	return &graphql_models.Recipe{
		ID: RecipeIDToGraphQL(id),
	}
}

func RecipeWithIntID(id int) *graphql_models.Recipe {
	return RecipeWithUintID(uint(id))
}

func RecipeWithNullDotUintID(id null.Uint) *graphql_models.Recipe {
	return RecipeWithUintID(id.Uint)
}

func RecipeWithNullDotIntID(id null.Int) *graphql_models.Recipe {
	return RecipeWithUintID(uint(id.Int))
}

func RecipesToGraphQL(am []*models.Recipe) []*graphql_models.Recipe {
	ar := make([]*graphql_models.Recipe, len(am))
	for i, m := range am {
		ar[i] = RecipeToGraphQL(m)
	}
	return ar
}

func RecipeIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.Recipe)
}

func RecipeToGraphQL(m *models.Recipe) *graphql_models.Recipe {
	if m == nil {
		return nil
	}

	r := &graphql_models.Recipe{

		ID:        RecipeIDToGraphQL(uint(m.ID)),
		Name:      m.Name,
		Note:      m.Note,
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if m.R != nil && m.R.RecipeAdditives != nil {
		r.RecipeAdditives = RecipeAdditivesToGraphQL(m.R.RecipeAdditives)
	}
	if m.R != nil && m.R.RecipeBatches != nil {
		r.RecipeBatches = RecipeBatchesToGraphQL(m.R.RecipeBatches)
	}
	if m.R != nil && m.R.RecipeFragrances != nil {
		r.RecipeFragrances = RecipeFragrancesToGraphQL(m.R.RecipeFragrances)
	}
	if m.R != nil && m.R.RecipeLipids != nil {
		r.RecipeLipids = RecipeLipidsToGraphQL(m.R.RecipeLipids)
	}
	if m.R != nil && m.R.RecipeSteps != nil {
		r.RecipeSteps = RecipeStepsToGraphQL(m.R.RecipeSteps)
	}

	return r
}

func RecipeID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeAdditiveWithUintID(id uint) *graphql_models.RecipeAdditive {
	return &graphql_models.RecipeAdditive{
		ID: RecipeAdditiveIDToGraphQL(id),
	}
}

func RecipeAdditiveWithIntID(id int) *graphql_models.RecipeAdditive {
	return RecipeAdditiveWithUintID(uint(id))
}

func RecipeAdditiveWithNullDotUintID(id null.Uint) *graphql_models.RecipeAdditive {
	return RecipeAdditiveWithUintID(id.Uint)
}

func RecipeAdditiveWithNullDotIntID(id null.Int) *graphql_models.RecipeAdditive {
	return RecipeAdditiveWithUintID(uint(id.Int))
}

func RecipeAdditivesToGraphQL(am []*models.RecipeAdditive) []*graphql_models.RecipeAdditive {
	ar := make([]*graphql_models.RecipeAdditive, len(am))
	for i, m := range am {
		ar[i] = RecipeAdditiveToGraphQL(m)
	}
	return ar
}

func RecipeAdditiveIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeAdditive)
}

func RecipeAdditiveToGraphQL(m *models.RecipeAdditive) *graphql_models.RecipeAdditive {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeAdditive{

		ID:         RecipeAdditiveIDToGraphQL(uint(m.ID)),
		Percentage: m.Percentage,
		CreatedAt:  boilergql.TimeDotTimeToInt(m.CreatedAt),
		UpdatedAt:  boilergql.TimeDotTimeToInt(m.UpdatedAt),
		DeletedAt:  boilergql.NullDotTimeToPointerInt(m.DeletedAt),
	}

	if boilergql.IntIsFilled(m.AdditiveID) {
		if m.R != nil && m.R.Additive != nil {
			r.Additive = AdditiveToGraphQL(m.R.Additive)
		} else {
			r.Additive = AdditiveWithIntID(m.AdditiveID)
		}
	}
	if boilergql.IntIsFilled(m.RecipeID) {
		if m.R != nil && m.R.Recipe != nil {
			r.Recipe = RecipeToGraphQL(m.R.Recipe)
		} else {
			r.Recipe = RecipeWithIntID(m.RecipeID)
		}
	}

	return r
}

func RecipeAdditiveID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeAdditiveIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeBatchWithUintID(id uint) *graphql_models.RecipeBatch {
	return &graphql_models.RecipeBatch{
		ID: RecipeBatchIDToGraphQL(id),
	}
}

func RecipeBatchWithIntID(id int) *graphql_models.RecipeBatch {
	return RecipeBatchWithUintID(uint(id))
}

func RecipeBatchWithNullDotUintID(id null.Uint) *graphql_models.RecipeBatch {
	return RecipeBatchWithUintID(id.Uint)
}

func RecipeBatchWithNullDotIntID(id null.Int) *graphql_models.RecipeBatch {
	return RecipeBatchWithUintID(uint(id.Int))
}

func RecipeBatchesToGraphQL(am []*models.RecipeBatch) []*graphql_models.RecipeBatch {
	ar := make([]*graphql_models.RecipeBatch, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchToGraphQL(m)
	}
	return ar
}

func RecipeBatchIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeBatch)
}

func RecipeBatchToGraphQL(m *models.RecipeBatch) *graphql_models.RecipeBatch {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeBatch{

		ID:               RecipeBatchIDToGraphQL(uint(m.ID)),
		Tag:              m.Tag,
		ProductionDate:   boilergql.TimeDotTimeToInt(m.ProductionDate),
		SellableDate:     boilergql.TimeDotTimeToInt(m.SellableDate),
		Note:             m.Note,
		LipidWeight:      m.LipidWeight,
		ProductionWeight: m.ProductionWeight,
		CuredWeight:      m.CuredWeight,
		CreatedAt:        boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt:        boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt:        boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if boilergql.IntIsFilled(m.RecipeID) {
		if m.R != nil && m.R.Recipe != nil {
			r.Recipe = RecipeToGraphQL(m.R.Recipe)
		} else {
			r.Recipe = RecipeWithIntID(m.RecipeID)
		}
	}
	if m.R != nil && m.R.BatchRecipeBatchAdditives != nil {
		r.BatchRecipeBatchAdditives = RecipeBatchAdditivesToGraphQL(m.R.BatchRecipeBatchAdditives)
	}
	if m.R != nil && m.R.BatchRecipeBatchFragrances != nil {
		r.BatchRecipeBatchFragrances = RecipeBatchFragrancesToGraphQL(m.R.BatchRecipeBatchFragrances)
	}
	if m.R != nil && m.R.BatchRecipeBatchLipids != nil {
		r.BatchRecipeBatchLipids = RecipeBatchLipidsToGraphQL(m.R.BatchRecipeBatchLipids)
	}
	if m.R != nil && m.R.BatchRecipeBatchLyes != nil {
		r.BatchRecipeBatchLyes = RecipeBatchLyesToGraphQL(m.R.BatchRecipeBatchLyes)
	}
	if m.R != nil && m.R.BatchRecipeBatchNotes != nil {
		r.BatchRecipeBatchNotes = RecipeBatchNotesToGraphQL(m.R.BatchRecipeBatchNotes)
	}

	return r
}

func RecipeBatchID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeBatchIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeBatchAdditiveWithUintID(id uint) *graphql_models.RecipeBatchAdditive {
	return &graphql_models.RecipeBatchAdditive{
		ID: RecipeBatchAdditiveIDToGraphQL(id),
	}
}

func RecipeBatchAdditiveWithIntID(id int) *graphql_models.RecipeBatchAdditive {
	return RecipeBatchAdditiveWithUintID(uint(id))
}

func RecipeBatchAdditiveWithNullDotUintID(id null.Uint) *graphql_models.RecipeBatchAdditive {
	return RecipeBatchAdditiveWithUintID(id.Uint)
}

func RecipeBatchAdditiveWithNullDotIntID(id null.Int) *graphql_models.RecipeBatchAdditive {
	return RecipeBatchAdditiveWithUintID(uint(id.Int))
}

func RecipeBatchAdditivesToGraphQL(am []*models.RecipeBatchAdditive) []*graphql_models.RecipeBatchAdditive {
	ar := make([]*graphql_models.RecipeBatchAdditive, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchAdditiveToGraphQL(m)
	}
	return ar
}

func RecipeBatchAdditiveIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeBatchAdditive)
}

func RecipeBatchAdditiveToGraphQL(m *models.RecipeBatchAdditive) *graphql_models.RecipeBatchAdditive {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeBatchAdditive{

		ID:        RecipeBatchAdditiveIDToGraphQL(uint(m.ID)),
		Weight:    m.Weight,
		Cost:      m.Cost,
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if boilergql.IntIsFilled(m.AdditiveID) {
		if m.R != nil && m.R.Additive != nil {
			r.Additive = AdditiveToGraphQL(m.R.Additive)
		} else {
			r.Additive = AdditiveWithIntID(m.AdditiveID)
		}
	}
	if boilergql.IntIsFilled(m.BatchID) {
		if m.R != nil && m.R.Batch != nil {
			r.Batch = RecipeBatchToGraphQL(m.R.Batch)
		} else {
			r.Batch = RecipeBatchWithIntID(m.BatchID)
		}
	}

	return r
}

func RecipeBatchAdditiveID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeBatchAdditiveIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeBatchFragranceWithUintID(id uint) *graphql_models.RecipeBatchFragrance {
	return &graphql_models.RecipeBatchFragrance{
		ID: RecipeBatchFragranceIDToGraphQL(id),
	}
}

func RecipeBatchFragranceWithIntID(id int) *graphql_models.RecipeBatchFragrance {
	return RecipeBatchFragranceWithUintID(uint(id))
}

func RecipeBatchFragranceWithNullDotUintID(id null.Uint) *graphql_models.RecipeBatchFragrance {
	return RecipeBatchFragranceWithUintID(id.Uint)
}

func RecipeBatchFragranceWithNullDotIntID(id null.Int) *graphql_models.RecipeBatchFragrance {
	return RecipeBatchFragranceWithUintID(uint(id.Int))
}

func RecipeBatchFragrancesToGraphQL(am []*models.RecipeBatchFragrance) []*graphql_models.RecipeBatchFragrance {
	ar := make([]*graphql_models.RecipeBatchFragrance, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchFragranceToGraphQL(m)
	}
	return ar
}

func RecipeBatchFragranceIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeBatchFragrance)
}

func RecipeBatchFragranceToGraphQL(m *models.RecipeBatchFragrance) *graphql_models.RecipeBatchFragrance {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeBatchFragrance{

		ID:        RecipeBatchFragranceIDToGraphQL(uint(m.ID)),
		Weight:    m.Weight,
		Cost:      m.Cost,
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if boilergql.IntIsFilled(m.FragranceID) {
		if m.R != nil && m.R.Fragrance != nil {
			r.Fragrance = FragranceToGraphQL(m.R.Fragrance)
		} else {
			r.Fragrance = FragranceWithIntID(m.FragranceID)
		}
	}
	if boilergql.IntIsFilled(m.BatchID) {
		if m.R != nil && m.R.Batch != nil {
			r.Batch = RecipeBatchToGraphQL(m.R.Batch)
		} else {
			r.Batch = RecipeBatchWithIntID(m.BatchID)
		}
	}

	return r
}

func RecipeBatchFragranceID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeBatchFragranceIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeBatchLipidWithUintID(id uint) *graphql_models.RecipeBatchLipid {
	return &graphql_models.RecipeBatchLipid{
		ID: RecipeBatchLipidIDToGraphQL(id),
	}
}

func RecipeBatchLipidWithIntID(id int) *graphql_models.RecipeBatchLipid {
	return RecipeBatchLipidWithUintID(uint(id))
}

func RecipeBatchLipidWithNullDotUintID(id null.Uint) *graphql_models.RecipeBatchLipid {
	return RecipeBatchLipidWithUintID(id.Uint)
}

func RecipeBatchLipidWithNullDotIntID(id null.Int) *graphql_models.RecipeBatchLipid {
	return RecipeBatchLipidWithUintID(uint(id.Int))
}

func RecipeBatchLipidsToGraphQL(am []*models.RecipeBatchLipid) []*graphql_models.RecipeBatchLipid {
	ar := make([]*graphql_models.RecipeBatchLipid, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchLipidToGraphQL(m)
	}
	return ar
}

func RecipeBatchLipidIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeBatchLipid)
}

func RecipeBatchLipidToGraphQL(m *models.RecipeBatchLipid) *graphql_models.RecipeBatchLipid {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeBatchLipid{

		ID:        RecipeBatchLipidIDToGraphQL(uint(m.ID)),
		Weight:    m.Weight,
		Cost:      m.Cost,
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
	}

	if boilergql.IntIsFilled(m.LipidID) {
		if m.R != nil && m.R.Lipid != nil {
			r.Lipid = LipidToGraphQL(m.R.Lipid)
		} else {
			r.Lipid = LipidWithIntID(m.LipidID)
		}
	}
	if boilergql.IntIsFilled(m.BatchID) {
		if m.R != nil && m.R.Batch != nil {
			r.Batch = RecipeBatchToGraphQL(m.R.Batch)
		} else {
			r.Batch = RecipeBatchWithIntID(m.BatchID)
		}
	}

	return r
}

func RecipeBatchLipidID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeBatchLipidIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeBatchLyeWithUintID(id uint) *graphql_models.RecipeBatchLye {
	return &graphql_models.RecipeBatchLye{
		ID: RecipeBatchLyeIDToGraphQL(id),
	}
}

func RecipeBatchLyeWithIntID(id int) *graphql_models.RecipeBatchLye {
	return RecipeBatchLyeWithUintID(uint(id))
}

func RecipeBatchLyeWithNullDotUintID(id null.Uint) *graphql_models.RecipeBatchLye {
	return RecipeBatchLyeWithUintID(id.Uint)
}

func RecipeBatchLyeWithNullDotIntID(id null.Int) *graphql_models.RecipeBatchLye {
	return RecipeBatchLyeWithUintID(uint(id.Int))
}

func RecipeBatchLyesToGraphQL(am []*models.RecipeBatchLye) []*graphql_models.RecipeBatchLye {
	ar := make([]*graphql_models.RecipeBatchLye, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchLyeToGraphQL(m)
	}
	return ar
}

func RecipeBatchLyeIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeBatchLye)
}

func RecipeBatchLyeToGraphQL(m *models.RecipeBatchLye) *graphql_models.RecipeBatchLye {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeBatchLye{

		ID:        RecipeBatchLyeIDToGraphQL(uint(m.ID)),
		Weight:    m.Weight,
		Discount:  m.Discount,
		Cost:      m.Cost,
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if boilergql.IntIsFilled(m.LyeID) {
		if m.R != nil && m.R.Lye != nil {
			r.Lye = LyeToGraphQL(m.R.Lye)
		} else {
			r.Lye = LyeWithIntID(m.LyeID)
		}
	}
	if boilergql.IntIsFilled(m.BatchID) {
		if m.R != nil && m.R.Batch != nil {
			r.Batch = RecipeBatchToGraphQL(m.R.Batch)
		} else {
			r.Batch = RecipeBatchWithIntID(m.BatchID)
		}
	}

	return r
}

func RecipeBatchLyeID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeBatchLyeIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeBatchNoteWithUintID(id uint) *graphql_models.RecipeBatchNote {
	return &graphql_models.RecipeBatchNote{
		ID: RecipeBatchNoteIDToGraphQL(id),
	}
}

func RecipeBatchNoteWithIntID(id int) *graphql_models.RecipeBatchNote {
	return RecipeBatchNoteWithUintID(uint(id))
}

func RecipeBatchNoteWithNullDotUintID(id null.Uint) *graphql_models.RecipeBatchNote {
	return RecipeBatchNoteWithUintID(id.Uint)
}

func RecipeBatchNoteWithNullDotIntID(id null.Int) *graphql_models.RecipeBatchNote {
	return RecipeBatchNoteWithUintID(uint(id.Int))
}

func RecipeBatchNotesToGraphQL(am []*models.RecipeBatchNote) []*graphql_models.RecipeBatchNote {
	ar := make([]*graphql_models.RecipeBatchNote, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchNoteToGraphQL(m)
	}
	return ar
}

func RecipeBatchNoteIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeBatchNote)
}

func RecipeBatchNoteToGraphQL(m *models.RecipeBatchNote) *graphql_models.RecipeBatchNote {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeBatchNote{

		ID:        RecipeBatchNoteIDToGraphQL(uint(m.ID)),
		Note:      m.Note,
		Link:      m.Link,
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if boilergql.IntIsFilled(m.BatchID) {
		if m.R != nil && m.R.Batch != nil {
			r.Batch = RecipeBatchToGraphQL(m.R.Batch)
		} else {
			r.Batch = RecipeBatchWithIntID(m.BatchID)
		}
	}

	return r
}

func RecipeBatchNoteID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeBatchNoteIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeFragranceWithUintID(id uint) *graphql_models.RecipeFragrance {
	return &graphql_models.RecipeFragrance{
		ID: RecipeFragranceIDToGraphQL(id),
	}
}

func RecipeFragranceWithIntID(id int) *graphql_models.RecipeFragrance {
	return RecipeFragranceWithUintID(uint(id))
}

func RecipeFragranceWithNullDotUintID(id null.Uint) *graphql_models.RecipeFragrance {
	return RecipeFragranceWithUintID(id.Uint)
}

func RecipeFragranceWithNullDotIntID(id null.Int) *graphql_models.RecipeFragrance {
	return RecipeFragranceWithUintID(uint(id.Int))
}

func RecipeFragrancesToGraphQL(am []*models.RecipeFragrance) []*graphql_models.RecipeFragrance {
	ar := make([]*graphql_models.RecipeFragrance, len(am))
	for i, m := range am {
		ar[i] = RecipeFragranceToGraphQL(m)
	}
	return ar
}

func RecipeFragranceIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeFragrance)
}

func RecipeFragranceToGraphQL(m *models.RecipeFragrance) *graphql_models.RecipeFragrance {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeFragrance{

		ID:         RecipeFragranceIDToGraphQL(uint(m.ID)),
		Percentage: m.Percentage,
		DeletedAt:  boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt:  boilergql.TimeDotTimeToInt(m.UpdatedAt),
		CreatedAt:  boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if boilergql.IntIsFilled(m.FragranceID) {
		if m.R != nil && m.R.Fragrance != nil {
			r.Fragrance = FragranceToGraphQL(m.R.Fragrance)
		} else {
			r.Fragrance = FragranceWithIntID(m.FragranceID)
		}
	}
	if boilergql.IntIsFilled(m.RecipeID) {
		if m.R != nil && m.R.Recipe != nil {
			r.Recipe = RecipeToGraphQL(m.R.Recipe)
		} else {
			r.Recipe = RecipeWithIntID(m.RecipeID)
		}
	}

	return r
}

func RecipeFragranceID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeFragranceIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeLipidWithUintID(id uint) *graphql_models.RecipeLipid {
	return &graphql_models.RecipeLipid{
		ID: RecipeLipidIDToGraphQL(id),
	}
}

func RecipeLipidWithIntID(id int) *graphql_models.RecipeLipid {
	return RecipeLipidWithUintID(uint(id))
}

func RecipeLipidWithNullDotUintID(id null.Uint) *graphql_models.RecipeLipid {
	return RecipeLipidWithUintID(id.Uint)
}

func RecipeLipidWithNullDotIntID(id null.Int) *graphql_models.RecipeLipid {
	return RecipeLipidWithUintID(uint(id.Int))
}

func RecipeLipidsToGraphQL(am []*models.RecipeLipid) []*graphql_models.RecipeLipid {
	ar := make([]*graphql_models.RecipeLipid, len(am))
	for i, m := range am {
		ar[i] = RecipeLipidToGraphQL(m)
	}
	return ar
}

func RecipeLipidIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeLipid)
}

func RecipeLipidToGraphQL(m *models.RecipeLipid) *graphql_models.RecipeLipid {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeLipid{

		ID:         RecipeLipidIDToGraphQL(uint(m.ID)),
		Percentage: m.Percentage,
		UpdatedAt:  boilergql.TimeDotTimeToInt(m.UpdatedAt),
		DeletedAt:  boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt:  boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if boilergql.IntIsFilled(m.LipidID) {
		if m.R != nil && m.R.Lipid != nil {
			r.Lipid = LipidToGraphQL(m.R.Lipid)
		} else {
			r.Lipid = LipidWithIntID(m.LipidID)
		}
	}
	if boilergql.IntIsFilled(m.RecipeID) {
		if m.R != nil && m.R.Recipe != nil {
			r.Recipe = RecipeToGraphQL(m.R.Recipe)
		} else {
			r.Recipe = RecipeWithIntID(m.RecipeID)
		}
	}

	return r
}

func RecipeLipidID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeLipidIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func RecipeStepWithUintID(id uint) *graphql_models.RecipeStep {
	return &graphql_models.RecipeStep{
		ID: RecipeStepIDToGraphQL(id),
	}
}

func RecipeStepWithIntID(id int) *graphql_models.RecipeStep {
	return RecipeStepWithUintID(uint(id))
}

func RecipeStepWithNullDotUintID(id null.Uint) *graphql_models.RecipeStep {
	return RecipeStepWithUintID(id.Uint)
}

func RecipeStepWithNullDotIntID(id null.Int) *graphql_models.RecipeStep {
	return RecipeStepWithUintID(uint(id.Int))
}

func RecipeStepsToGraphQL(am []*models.RecipeStep) []*graphql_models.RecipeStep {
	ar := make([]*graphql_models.RecipeStep, len(am))
	for i, m := range am {
		ar[i] = RecipeStepToGraphQL(m)
	}
	return ar
}

func RecipeStepIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.RecipeStep)
}

func RecipeStepToGraphQL(m *models.RecipeStep) *graphql_models.RecipeStep {
	if m == nil {
		return nil
	}

	r := &graphql_models.RecipeStep{

		ID:        RecipeStepIDToGraphQL(uint(m.ID)),
		Num:       m.Num,
		Note:      m.Note,
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
	}

	if boilergql.IntIsFilled(m.RecipeID) {
		if m.R != nil && m.R.Recipe != nil {
			r.Recipe = RecipeToGraphQL(m.R.Recipe)
		} else {
			r.Recipe = RecipeWithIntID(m.RecipeID)
		}
	}

	return r
}

func RecipeStepID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func RecipeStepIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}

func SupplierWithUintID(id uint) *graphql_models.Supplier {
	return &graphql_models.Supplier{
		ID: SupplierIDToGraphQL(id),
	}
}

func SupplierWithIntID(id int) *graphql_models.Supplier {
	return SupplierWithUintID(uint(id))
}

func SupplierWithNullDotUintID(id null.Uint) *graphql_models.Supplier {
	return SupplierWithUintID(id.Uint)
}

func SupplierWithNullDotIntID(id null.Int) *graphql_models.Supplier {
	return SupplierWithUintID(uint(id.Int))
}

func SuppliersToGraphQL(am []*models.Supplier) []*graphql_models.Supplier {
	ar := make([]*graphql_models.Supplier, len(am))
	for i, m := range am {
		ar[i] = SupplierToGraphQL(m)
	}
	return ar
}

func SupplierIDToGraphQL(v uint) string {
	return boilergql.IDToGraphQL(v, models.TableNames.Supplier)
}

func SupplierToGraphQL(m *models.Supplier) *graphql_models.Supplier {
	if m == nil {
		return nil
	}

	r := &graphql_models.Supplier{

		ID:        SupplierIDToGraphQL(uint(m.ID)),
		Name:      m.Name,
		Website:   m.Website,
		Note:      m.Note,
		CreatedAt: boilergql.TimeDotTimeToInt(m.CreatedAt),
		DeletedAt: boilergql.NullDotTimeToPointerInt(m.DeletedAt),
		UpdatedAt: boilergql.TimeDotTimeToInt(m.UpdatedAt),
	}

	if m.R != nil && m.R.AdditiveInventories != nil {
		r.AdditiveInventories = AdditiveInventoriesToGraphQL(m.R.AdditiveInventories)
	}
	if m.R != nil && m.R.FragranceInventories != nil {
		r.FragranceInventories = FragranceInventoriesToGraphQL(m.R.FragranceInventories)
	}
	if m.R != nil && m.R.LipidInventories != nil {
		r.LipidInventories = LipidInventoriesToGraphQL(m.R.LipidInventories)
	}
	if m.R != nil && m.R.LyeInventories != nil {
		r.LyeInventories = LyeInventoriesToGraphQL(m.R.LyeInventories)
	}

	return r
}

func SupplierID(v string) int {
	return boilergql.IDToBoilerInt(v)
}

func SupplierIDs(a []string) []int {
	return boilergql.IDsToBoilerInt(a)
}
